---
layout: post
title:  "CodeQL 0x00: The story of a cat that hunt bugs"
categories: tools
tags: codeql tutorial
author: th3_5had0w
mathjax: true
---

* content
{:toc}

As the source codes being more and more complex these days, the way we search for functions, arguments with patterns in code editors is inconvenient. There's another better way to help you achieve that goal...




# Introduction

CodeQL is a query language that helps you search for critical things in the source code with your own constraints, I've just got to know about it recently. So this series will be me noting things I've learnt while using CodeQL to automate source code auditing. It might be helpful for those tired of searching code patterns in massive codebase.

# Environment setup

Setting up the environment is pretty basic, we need to have these things for a properly working CodeQL environment:

- CodeQL (of course) - I'll be using CodeQL Visual Studio Plugin, you could search for it in [vscode extension store](https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql)

- [A CodeQL workspace to use with Visual Studio CodeQL plugin.](https://github.com/github/vscode-codeql-starter/)

- A database that so that you could run queries against it.

For the CodeQL vscode plugin and the workspace, I suggest follow the instructions in the links above.

About the database, I will choose [Glibc-2.35](https://ftp.gnu.org/gnu/glibc/glibc-2.35.tar.gz) as the source auditing target. To build the [Glibc source as the database](https://codeql.github.com/docs/codeql-cli/creating-codeql-databases/), you need to get the codeql-cli binary [here](https://github.com/github/codeql-cli-binaries/releases).

Now for the build part:
```
5439 Sarmat λ  (~/Desktop/codeql-playground)
 $ ls
codeql-linux64  glibc-2.35.tar.gz

5439 Sarmat λ  (~/Desktop/codeql-playground)
 $ tar xf glibc-2.35.tar.gz 

5439 Sarmat λ  (~/Desktop/codeql-playground)
 $ cd glibc-2.35/

5439 Sarmat λ  (~/.../codeql-playground/glibc-2.35)
 $ mkdir build && cd build

5439 Sarmat λ  (~/.../codeql-playground/glibc-2.35/build)
 $ ../configure
```

After configuring the source, we will now generate CodeQL database for the source with:
```
../../codeql-linux64/codeql/codeql database create <your-database-name> --language=cpp --command=make
```

I use the default name for database cpp-database. After the above command had ran successfully you will see a folder that has the same name as your database name you defined in the command line above. For me it's cpp-database, this folder will now be used as the database for you to run queries on. You could leave it be and add it as the folder or compress it and add it as an archive. Personally I compress the database because it's easy to transfer between VMs and hosts.

If you successfully added the database to CodeQL plugin the database will appear like this

![](/assets/codeql_1.png)

# Looking for function calls - "Hello! Who's calling me?"

* Note: Like I said, I've just got to know about CodeQL recently so my explain for the queries might not be so accurate, so if you notice some thing I won't correctly explain please let me know. Thanks.

So after had set up the environment, now we will write the query in the CodeQL workspace. I suggest you place your queries in `codeql-custom-queries-cpp` folder like this.

![](/assets/codeql_2.png)

So let's start with a basic query that will return to us every single place in the Glibc source code that calls `malloc`:

```sql
import cpp

from FunctionCall c
where c.getTarget().hasName("malloc")
select c
```

The query above return back to us places where the `Function` being called (target function) has the name "`malloc`".

You can see because CodeQL is a query language so its syntax is somewhat familiar to SQL.

![](/assets/codeql_6.png)

Run it, if nothing goes wrong the result should look like this:

![](/assets/codeql_3.png)

I suggest you should stop here. Play around a little with the result (I mean click it and see where it leads you to) to have a better understanding of the query.

There is no "proper" way to write these kind of queries, you can do it however you want. Below is another query which have the same functionality, check it result for comparison:

```sql
import cpp

from FunctionCall c
where c.getTarget().getName() = "malloc"
select c
```

Now I want to add some filter to make the query result more accurate:

```sql
import cpp

from FunctionCall c
where c.getTarget().getName().regexpMatch(".*malloc")
select c
```

My query search for places where those `Function` being called (target function) has "`malloc`" as its suffix. We shall check the result to confirm what I've just explained.

![](/assets/codeql_4.png)

![](/assets/codeql_5.png)

You could add more constraint to your filter using the keyword `or`, `and`.

For some reason, I don't want to query those "`xmalloc`", I edited my query:

```sql
import cpp

from FunctionCall c
where c.getTarget().getName().regexpMatch(".*malloc")
and c.getTarget().getName() != "xmalloc"
select c
```

Run the query and I shouldn't any xmalloc in the result.

The result is still enormous in number, and I'm not satisfied. So I will narrow down the range of the result once more:

```sql
import cpp

from FunctionCall c
where c.getTarget().getName().regexpMatch(".*malloc")
and c.getFile().getBaseName() = "malloc.c"
and c.getArgument(0).getUnderlyingType() instanceof IntegralType
select c, c.getArgument(0)
```

So here I query places where those `Function` being called (target function) has "`malloc`" as its suffix but only in the file named "`malloc.c`" and first argument is `int` type. The result looks very promising.

![](/assets/codeql_7.png)

Next I will write some queries to play around with flow analysing.

# Query program flow - "My dear! Where are you going?"

Below is a script that query the "local program flow", meaning it's query the references between some of the function and argument in the same scope of a function:

```sql
import cpp
import semmle.code.cpp.dataflow.DataFlow

from FunctionCall fc, Expr source
where fc.getTarget().getName().matches("%_int_malloc%")
and DataFlow::localFlow(DataFlow::exprNode(source), DataFlow::exprNode(fc.getArgument(0)))
select source, fc.getArgument(0) as argument
```

There's a new function DataFlow::localFlow you might haven't seen before. According to the document:

```
localFlow(Node source, Node sink)

Holds if data flows from "source" to "sink" in zero or more local (intra-procedural) steps
```

The `DataFlow::localFlow` takes 2 argument, the `source` (Node type) and the `sink` (Node type). Just think the `source` and `sink` like the start point and the end point of a pipe, in that pipe the data flows.

So what am I doing with my script?

Just a glance at it and you could see that the `source` only have one constraint (the `source` must have it's "end" some relate with first argument of `_int_malloc` calls), playing around with the result might help you understand what I say because it's pretty abstract @@

![](/assets/codeql_8.png)

So look here you might see some pair of `source` and `sink` that is the same, meaning it also return when the variable "flows" to itself, so I made a small change in the script:

```sql
from FunctionCall fc, Expr source
where fc.getTarget().getName().matches("%_int_malloc%")
and DataFlow::localFlow(DataFlow::exprNode(source), DataFlow::exprNode(fc.getArgument(0)))
and source.toString() != fc.getArgument(0).toString()
select source, fc.getArgument(0) as argument
```

![](/assets/codeql_9.png)

Now you can all of those useless pair has disappeared